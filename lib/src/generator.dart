import 'dart:async';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';
import 'annotations.dart';

/// Code generator for @SafeJsonParsing annotation
/// 
/// This generator creates enhanced fromJsonSafe() methods that provide
/// crystal-clear error messages and automatic safe parsing.
class SafeJsonParsingGenerator extends GeneratorForAnnotation<SafeJsonParsing> {
  @override
  FutureOr<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) {
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
        '@SafeJsonParsing can only be applied to classes',
        element: element,
      );
    }

    return _generateSafeJsonMethod(element, annotation);
  }

  String _generateSafeJsonMethod(ClassElement classElement, ConstantReader annotation) {
    final className = classElement.name;
    final nullSafety = annotation.read('nullSafety').boolValue;
    final validateRequiredKeys = annotation.read('validateRequiredKeys').boolValue;
    final methodName = annotation.read('methodName').stringValue;

    // Get constructor parameters
    final defaultConstructors = classElement.constructors
        .where((c) => c.name.isEmpty)
        .toList();
    final constructor = defaultConstructors.isNotEmpty ? defaultConstructors.first : null;

    if (constructor == null) {
      throw InvalidGenerationSourceError(
        'Class $className must have a default constructor',
        element: classElement,
      );
    }

    final buffer = StringBuffer();
    
    // Generate the safe parsing method
    buffer.writeln('// Enhanced JSON parsing extension for $className');
    buffer.writeln('extension ${className}SafeJsonParsing on $className {');
    buffer.writeln('  /// Enhanced JSON parsing with detailed error messages');
    buffer.writeln('  /// ');
    buffer.writeln('  /// This method provides crystal-clear error messages when JSON parsing fails,');
    buffer.writeln('  /// including the exact field that caused the error, expected vs actual types,');
    buffer.writeln('  /// and copy-paste ready solutions to fix the issue.');
    buffer.writeln('  /// ');
    buffer.writeln('  /// Generated by @SafeJsonParsing annotation');
    buffer.writeln('  static $className $methodName(Map<String, dynamic> json) {');

    // Add required keys validation if requested
    if (validateRequiredKeys) {
      final requiredKeys = constructor.parameters
          .where((p) => !p.isOptional && !_isNullable(p.type))
          .map((p) => "'${_getJsonKey(p)}'")
          .toList();
      
      if (requiredKeys.isNotEmpty) {
        buffer.writeln('    json.requireKeys([${requiredKeys.join(', ')}]);');
        buffer.writeln('');
      }
    }

    // Generate the constructor call with safe parsing
    buffer.writeln('    return $className(');
    
    for (final param in constructor.parameters) {
      final fieldName = param.name;
      final jsonKey = _getJsonKey(param);
      final isNullable = _isNullable(param.type);
      final fieldAnnotation = _getSafeJsonFieldAnnotation(param);
      
      // Generate safe parsing call based on type and nullability
      final parseCall = _generateParseCall(
        jsonKey: jsonKey, 
        paramType: param.type, 
        isNullable: isNullable,
        nullSafety: nullSafety,
        fieldAnnotation: fieldAnnotation,
      );
      
      buffer.writeln('      $fieldName: $parseCall,');
    }
    
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');

    return buffer.toString();
  }

  String _generateParseCall({
    required String jsonKey,
    required DartType paramType,
    required bool isNullable,
    required bool nullSafety,
    SafeJsonFieldAnnotation? fieldAnnotation,
  }) {
    final typeName = paramType.getDisplayString(withNullability: false);
    
    // Handle custom parser if specified
    if (fieldAnnotation?.customParser != null) {
      return isNullable && nullSafety
          ? "json.getNullableSafe('$jsonKey', ${fieldAnnotation!.customParser})"
          : "json.getSafe('$jsonKey', ${fieldAnnotation!.customParser})";
    }

    // Handle enhanced context if specified
    if (fieldAnnotation != null && (
        fieldAnnotation.description != null ||
        fieldAnnotation.expectedFormat != null ||
        fieldAnnotation.commonValues != null)) {
      
      final contextParams = <String>[];
      if (fieldAnnotation.description != null) {
        contextParams.add("fieldDescription: '${fieldAnnotation.description}'");
      }
      if (fieldAnnotation.expectedFormat != null) {
        contextParams.add("expectedFormat: '${fieldAnnotation.expectedFormat}'");
      }
      if (fieldAnnotation.commonValues != null) {
        final values = fieldAnnotation.commonValues!.map((v) => "'$v'").join(', ');
        contextParams.add("commonValues: [$values]");
      }
      
      final contextCall = contextParams.isNotEmpty ? ', ${contextParams.join(', ')}' : '';
      
      return isNullable && nullSafety
          ? "json.getNullableSafeWithContext('$jsonKey', ${_getTypeParser(typeName)}$contextCall)"
          : "json.getSafeWithContext('$jsonKey', ${_getTypeParser(typeName)}$contextCall)";
    }

    // Handle common types with convenience methods
    final convenienceMethod = _getConvenienceMethod(typeName, isNullable && nullSafety);
    if (convenienceMethod != null) {
      return "$convenienceMethod('$jsonKey')";
    }

    // Handle lists
    if (paramType.isDartCoreList) {
      final typeArgs = (paramType as InterfaceType).typeArguments;
      if (typeArgs.isNotEmpty) {
        final elementType = typeArgs.first;
        final elementTypeName = elementType.getDisplayString(withNullability: false);
        final elementParser = _getTypeParser(elementTypeName);
        
        return isNullable && nullSafety
            ? "json.getNullableSafeList('$jsonKey', $elementParser)"
            : "json.getSafeList('$jsonKey', $elementParser)";
      }
    }

    // Handle nested objects
    if (_isCustomClass(paramType)) {
      final factoryMethod = '$typeName.fromJsonSafe';
      return isNullable && nullSafety
          ? "json.getNullableSafeObject('$jsonKey', $factoryMethod)"
          : "json.getSafeObject('$jsonKey', $factoryMethod)";
    }

    // Default generic parser
    final parser = _getTypeParser(typeName);
    return isNullable && nullSafety
        ? "json.getNullableSafe('$jsonKey', $parser)"
        : "json.getSafe('$jsonKey', $parser)";
  }

  String? _getConvenienceMethod(String typeName, bool isNullable) {
    final prefix = isNullable ? 'json.getNullableSafe' : 'json.getSafe';
    
    switch (typeName) {
      case 'String': return '${prefix}String';
      case 'int': return '${prefix}Int';
      case 'double': return '${prefix}Double';
      case 'bool': return '${prefix}Bool';
      case 'DateTime': return '${prefix}DateTime';
      default: return null;
    }
  }

  String _getTypeParser(String typeName) {
    switch (typeName) {
      case 'String': return '(v) => v as String';
      case 'int': return '(v) => (v as num).toInt()';
      case 'double': return '(v) => (v as num).toDouble()';
      case 'bool': return '(v) => v as bool';
      case 'DateTime': return '(v) => DateTime.parse(v as String)';
      default: return '(v) => v as $typeName';
    }
  }

  bool _isNullable(DartType type) {
    return type.nullabilitySuffix == NullabilitySuffix.question;
  }

  bool _isCustomClass(DartType type) {
    return !type.isDartCoreType && 
           !type.isDartCoreList && 
           !type.isDartCoreMap &&
           !type.isDartCoreSet;
  }

  String _getJsonKey(ParameterElement param) {
    // Check for @JsonKey annotation on the field (not parameter)
    // Look for the field in the class that matches this parameter
    final classElement = param.enclosingElement as ConstructorElement;
    final fields = (classElement.enclosingElement as ClassElement).fields;
    
    for (final field in fields) {
      if (field.name == param.name) {
        final jsonKeyAnnotations = field.metadata
            .where((m) => m.element?.displayName == 'JsonKey')
            .toList();
        final jsonKeyAnnotation = jsonKeyAnnotations.isNotEmpty ? jsonKeyAnnotations.first : null;
        
        if (jsonKeyAnnotation != null) {
          final reader = ConstantReader(jsonKeyAnnotation.computeConstantValue());
          final name = reader.peek('name')?.stringValue;
          if (name != null) return name;
        }
        break;
      }
    }
    
    // Default to parameter name
    return param.name;
  }

  SafeJsonFieldAnnotation? _getSafeJsonFieldAnnotation(ParameterElement param) {
    // Check for @SafeJsonField annotation on the field (not parameter)
    final classElement = param.enclosingElement as ConstructorElement;
    final fields = (classElement.enclosingElement as ClassElement).fields;
    
    for (final field in fields) {
      if (field.name == param.name) {
        final annotations = field.metadata
            .where((m) => m.element?.displayName == 'SafeJsonField')
            .toList();
        final annotation = annotations.isNotEmpty ? annotations.first : null;
        
        if (annotation == null) return null;
        
        final reader = ConstantReader(annotation.computeConstantValue());
        
        return SafeJsonFieldAnnotation(
          description: reader.peek('description')?.stringValue,
          expectedFormat: reader.peek('expectedFormat')?.stringValue,
          commonValues: reader.peek('commonValues')?.listValue
              .map((e) => e.toStringValue())
              .where((e) => e != null)
              .cast<String>()
              .toList(),
          customParser: reader.peek('customParser')?.stringValue,
          enhancedErrors: reader.peek('enhancedErrors')?.boolValue ?? true,
        );
      }
    }
    
    return null;
  }
}

/// Internal representation of SafeJsonField annotation data
/// 
/// This class holds the parsed configuration from @SafeJsonField annotations
/// and is used internally by the code generator to create enhanced error messages.
class SafeJsonFieldAnnotation {
  /// Human-readable description of what this field represents
  /// 
  /// Used in error messages to provide context about the field's purpose.
  /// Example: "User email address" or "Product price in USD"
  final String? description;
  
  /// Expected format or example value for this field
  /// 
  /// Shown in error messages to help developers understand the expected format.
  /// Example: "user@example.com" or "Positive number (e.g., 19.99)"
  final String? expectedFormat;
  
  /// List of common/valid values for this field
  /// 
  /// Displayed in error messages as examples of acceptable values.
  /// Example: ['9.99', '19.99', '29.99'] for a price field
  final List<String>? commonValues;
  
  /// Name of a custom static parser method to use for this field
  /// 
  /// References a static method that should handle parsing this specific field.
  /// The method should have signature: `static T methodName(dynamic value)`
  final String? customParser;
  
  /// Whether this field should use enhanced error reporting
  /// 
  /// When true, generates detailed error messages with context and suggestions.
  /// When false, uses standard error reporting. Defaults to true.
  final bool enhancedErrors;

  /// Creates a new SafeJsonFieldAnnotation with the specified configuration
  /// 
  /// This constructor is used internally by the code generator to create
  /// annotation instances from @SafeJsonField metadata.
  SafeJsonFieldAnnotation({
    this.description,
    this.expectedFormat,
    this.commonValues,
    this.customParser,
    required this.enhancedErrors,
  });
}

/// Builder for the safe JSON parsing generator
Builder safeJsonParsingBuilder(BuilderOptions options) {
  return PartBuilder([SafeJsonParsingGenerator()], '.safe_json_parsing.g.dart');
}
