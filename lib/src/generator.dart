import 'dart:async';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';
import 'package:json_annotation/json_annotation.dart';
import 'annotations.dart';

/// Code generator for @SafeJsonParsing annotation
/// 
/// This generator creates enhanced fromJsonSafe() methods that provide
/// crystal-clear error messages and automatic safe parsing.
class SafeJsonParsingGenerator extends GeneratorForAnnotation<SafeJsonParsing> {
  @override
  FutureOr<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) {
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
        '@SafeJsonParsing can only be applied to classes',
        element: element,
      );
    }

    return _generateSafeJsonMethod(element, annotation);
  }

  String _generateSafeJsonMethod(ClassElement classElement, ConstantReader annotation) {
    final className = classElement.name;
    final nullSafety = annotation.read('nullSafety').boolValue;
    final validateRequiredKeys = annotation.read('validateRequiredKeys').boolValue;
    final methodName = annotation.read('methodName').stringValue;
    final generateBothMethods = annotation.read('generateBothMethods').boolValue;

    // Get constructor parameters
    final constructor = classElement.constructors
        .where((c) => c.name.isEmpty)
        .firstOrNull;

    if (constructor == null) {
      throw InvalidGenerationSourceError(
        'Class $className must have a default constructor',
        element: classElement,
      );
    }

    final buffer = StringBuffer();
    
    // Generate the safe parsing method
    buffer.writeln('  /// Enhanced JSON parsing with detailed error messages');
    buffer.writeln('  /// ');
    buffer.writeln('  /// This method provides crystal-clear error messages when JSON parsing fails,');
    buffer.writeln('  /// including the exact field that caused the error, expected vs actual types,');
    buffer.writeln('  /// and copy-paste ready solutions to fix the issue.');
    buffer.writeln('  /// ');
    buffer.writeln('  /// Generated by @SafeJsonParsing annotation');
    buffer.writeln('  static $className $methodName(Map<String, dynamic> json) {');

    // Add required keys validation if requested
    if (validateRequiredKeys) {
      final requiredKeys = constructor.parameters
          .where((p) => !p.isOptional && !_isNullable(p.type))
          .map((p) => "'${_getJsonKey(p)}'")
          .toList();
      
      if (requiredKeys.isNotEmpty) {
        buffer.writeln('    json.requireKeys([${requiredKeys.join(', ')}]);');
        buffer.writeln('');
      }
    }

    // Generate the constructor call with safe parsing
    buffer.writeln('    return $className(');
    
    for (final param in constructor.parameters) {
      final fieldName = param.name;
      final jsonKey = _getJsonKey(param);
      final isNullable = _isNullable(param.type);
      final fieldAnnotation = _getSafeJsonFieldAnnotation(param);
      
      // Generate safe parsing call based on type and nullability
      final parseCall = _generateParseCall(
        jsonKey: jsonKey, 
        paramType: param.type, 
        isNullable: isNullable,
        nullSafety: nullSafety,
        fieldAnnotation: fieldAnnotation,
      );
      
      buffer.writeln('      $fieldName: $parseCall,');
    }
    
    buffer.writeln('    );');
    buffer.writeln('  }');

    return buffer.toString();
  }

  String _generateParseCall({
    required String jsonKey,
    required DartType paramType,
    required bool isNullable,
    required bool nullSafety,
    SafeJsonFieldAnnotation? fieldAnnotation,
  }) {
    final typeName = paramType.getDisplayString(withNullability: false);
    
    // Handle custom parser if specified
    if (fieldAnnotation?.customParser != null) {
      return isNullable && nullSafety
          ? "json.getNullableSafe('$jsonKey', ${fieldAnnotation!.customParser})"
          : "json.getSafe('$jsonKey', ${fieldAnnotation!.customParser})";
    }

    // Handle enhanced context if specified
    if (fieldAnnotation != null && (
        fieldAnnotation.description != null ||
        fieldAnnotation.expectedFormat != null ||
        fieldAnnotation.commonValues != null)) {
      
      final contextParams = <String>[];
      if (fieldAnnotation.description != null) {
        contextParams.add("fieldDescription: '${fieldAnnotation.description}'");
      }
      if (fieldAnnotation.expectedFormat != null) {
        contextParams.add("expectedFormat: '${fieldAnnotation.expectedFormat}'");
      }
      if (fieldAnnotation.commonValues != null) {
        final values = fieldAnnotation.commonValues!.map((v) => "'$v'").join(', ');
        contextParams.add("commonValues: [$values]");
      }
      
      final contextCall = contextParams.isNotEmpty ? ', ${contextParams.join(', ')}' : '';
      
      return isNullable && nullSafety
          ? "json.getNullableSafeWithContext('$jsonKey', ${_getTypeParser(typeName)}$contextCall)"
          : "json.getSafeWithContext('$jsonKey', ${_getTypeParser(typeName)}$contextCall)";
    }

    // Handle common types with convenience methods
    final convenienceMethod = _getConvenienceMethod(typeName, isNullable && nullSafety);
    if (convenienceMethod != null) {
      return "$convenienceMethod('$jsonKey')";
    }

    // Handle lists
    if (paramType.isDartCoreList) {
      final elementType = (paramType as InterfaceType).typeArguments.first;
      final elementTypeName = elementType.getDisplayString(withNullability: false);
      final elementParser = _getTypeParser(elementTypeName);
      
      return isNullable && nullSafety
          ? "json.getNullableSafeList('$jsonKey', $elementParser)"
          : "json.getSafeList('$jsonKey', $elementParser)";
    }

    // Handle nested objects
    if (_isCustomClass(paramType)) {
      final factoryMethod = '${typeName}.fromJsonSafe';
      return isNullable && nullSafety
          ? "json.getNullableSafeObject('$jsonKey', $factoryMethod)"
          : "json.getSafeObject('$jsonKey', $factoryMethod)";
    }

    // Default generic parser
    final parser = _getTypeParser(typeName);
    return isNullable && nullSafety
        ? "json.getNullableSafe('$jsonKey', $parser)"
        : "json.getSafe('$jsonKey', $parser)";
  }

  String? _getConvenienceMethod(String typeName, bool isNullable) {
    final prefix = isNullable ? 'json.getNullableSafe' : 'json.getSafe';
    
    switch (typeName) {
      case 'String': return '${prefix}String';
      case 'int': return '${prefix}Int';
      case 'double': return '${prefix}Double';
      case 'bool': return '${prefix}Bool';
      case 'DateTime': return '${prefix}DateTime';
      default: return null;
    }
  }

  String _getTypeParser(String typeName) {
    switch (typeName) {
      case 'String': return '(v) => v as String';
      case 'int': return '(v) => (v as num).toInt()';
      case 'double': return '(v) => (v as num).toDouble()';
      case 'bool': return '(v) => v as bool';
      case 'DateTime': return '(v) => DateTime.parse(v as String)';
      default: return '(v) => v as $typeName';
    }
  }

  bool _isNullable(DartType type) {
    return type.nullabilitySuffix == NullabilitySuffix.question;
  }

  bool _isCustomClass(DartType type) {
    return !type.isDartCoreType && 
           !type.isDartCoreList && 
           !type.isDartCoreMap &&
           !type.isDartCoreSet;
  }

  String _getJsonKey(ParameterElement param) {
    // Check for @JsonKey annotation
    final jsonKeyAnnotation = param.metadata
        .where((m) => m.element?.displayName == 'JsonKey')
        .firstOrNull;
    
    if (jsonKeyAnnotation != null) {
      final reader = ConstantReader(jsonKeyAnnotation.computeConstantValue());
      final name = reader.peek('name')?.stringValue;
      if (name != null) return name;
    }
    
    // Default to parameter name
    return param.name;
  }

  SafeJsonFieldAnnotation? _getSafeJsonFieldAnnotation(ParameterElement param) {
    final annotation = param.metadata
        .where((m) => m.element?.displayName == 'SafeJsonField')
        .firstOrNull;
    
    if (annotation == null) return null;
    
    final reader = ConstantReader(annotation.computeConstantValue());
    
    return SafeJsonFieldAnnotation(
      description: reader.peek('description')?.stringValue,
      expectedFormat: reader.peek('expectedFormat')?.stringValue,
      commonValues: reader.peek('commonValues')?.listValue
          ?.map((e) => e.toStringValue())
          ?.where((e) => e != null)
          ?.cast<String>()
          ?.toList(),
      customParser: reader.peek('customParser')?.stringValue,
      enhancedErrors: reader.peek('enhancedErrors')?.boolValue ?? true,
    );
  }
}

/// Internal representation of SafeJsonField annotation data
class SafeJsonFieldAnnotation {
  final String? description;
  final String? expectedFormat;
  final List<String>? commonValues;
  final String? customParser;
  final bool enhancedErrors;

  SafeJsonFieldAnnotation({
    this.description,
    this.expectedFormat,
    this.commonValues,
    this.customParser,
    required this.enhancedErrors,
  });
}

/// Builder for the safe JSON parsing generator
Builder safeJsonParsingBuilder(BuilderOptions options) {
  return SharedPartBuilder([SafeJsonParsingGenerator()], 'safe_json_parsing');
}
