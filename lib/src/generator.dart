import 'dart:async';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';
import 'annotations.dart';

/// Code generator for @SafeJsonParsing annotation
///
/// This generator creates enhanced fromJsonSafe() methods that provide
/// crystal-clear error messages and automatic safe parsing.
class SafeJsonParsingGenerator extends GeneratorForAnnotation<SafeJsonParsing> {
  @override
  FutureOr<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) {
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
        '@SafeJsonParsing can only be applied to classes',
        element: element,
      );
    }

    return _generateSafeJsonMethod(element, annotation);
  }

  String _generateSafeJsonMethod(
    ClassElement classElement,
    ConstantReader annotation,
  ) {
    final className = classElement.name;
    final nullSafety = annotation.read('nullSafety').boolValue;
    final validateRequiredKeys =
        annotation.read('validateRequiredKeys').boolValue;
    final methodName = annotation.read('methodName').stringValue;

    // Note: We use field-based generation, so no constructor validation needed

    final buffer = StringBuffer();

    // Generate the safe parsing method
    buffer.writeln('// Enhanced JSON parsing extension for $className');
    buffer.writeln('extension ${className}SafeJsonParsing on $className {');
    buffer.writeln('  /// Enhanced JSON parsing with detailed error messages');
    buffer.writeln('  /// ');
    buffer.writeln(
      '  /// This method provides crystal-clear error messages when JSON parsing fails,',
    );
    buffer.writeln(
      '  /// including the exact field that caused the error, expected vs actual types,',
    );
    buffer.writeln('  /// and copy-paste ready solutions to fix the issue.');
    buffer.writeln('  /// ');
    buffer.writeln('  /// Generated by @SafeJsonParsing annotation');
    buffer.writeln(
      '  static $className $methodName(Map<String, dynamic> json) {',
    );

    // Add required keys validation if requested
    if (validateRequiredKeys) {
      final requiredKeys =
          classElement.fields
              .where((f) => !f.type.isDartCoreNull && !_isNullable(f.type))
              .map((f) => "'${_getJsonKeyFromField(f)}'")
              .toList();

      if (requiredKeys.isNotEmpty) {
        buffer.writeln('    json.requireKeys([${requiredKeys.join(', ')}]);');
        buffer.writeln('');
      }
    }

    final fieldMap = _collectInstanceFields(classElement);
    _writeConstructorInvocation(
      buffer: buffer,
      classElement: classElement,
      fieldMap: fieldMap,
      nullSafety: nullSafety,
    );
    buffer.writeln('  }');
    buffer.writeln('}');

    return buffer.toString();
  }

  Map<String, FieldElement> _collectInstanceFields(ClassElement classElement) {
    final result = <String, FieldElement>{};
    for (final field in classElement.fields) {
      if (field.isStatic) continue;
      final fieldName = field.name;
      if (fieldName == null || fieldName.isEmpty) continue;
      result[fieldName] = field;
    }
    return result;
  }

  void _writeConstructorInvocation({
    required StringBuffer buffer,
    required ClassElement classElement,
    required Map<String, FieldElement> fieldMap,
    required bool nullSafety,
  }) {
    final className = classElement.name;

    if (classElement.isAbstract) {
      buffer.writeln('    try {');
      buffer.writeln('      return $className.fromJson(json);');
      buffer.writeln('    } catch (error) {');
      buffer.writeln('      if (error is FormatException) rethrow;');
      buffer.writeln(
        "      throw FormatException(\"Error parsing $className: \$error\");",
      );
      buffer.writeln('    }');
      return;
    }

    final ctor = classElement.unnamedConstructor;
    if (ctor == null || ctor.isFactory) {
      buffer.writeln('    return $className(');
      for (final entry in fieldMap.entries) {
        final field = entry.value;
        final jsonKey = _getJsonKeyFromField(field);
        final parseCall = _generateParseCall(
          jsonKey: jsonKey,
          paramType: field.type,
          isNullable: _isNullable(field.type),
          nullSafety: nullSafety,
          fieldAnnotation: _getSafeJsonFieldAnnotationFromField(field),
        );
        buffer.writeln('      ${entry.key}: $parseCall,');
      }
      buffer.writeln('    );');
      return;
    }

    buffer.writeln('    return $className(');
    for (final param in ctor.formalParameters) {
      final paramName = param.displayName;
      final field = fieldMap[paramName];
      final jsonKey = field != null ? _getJsonKeyFromField(field) : paramName;
      final paramType = field?.type ?? param.type;
      final isNullable =
          field != null ? _isNullable(field.type) : _isNullable(paramType);
      final fieldAnnotation =
          field != null ? _getSafeJsonFieldAnnotationFromField(field) : null;

      final parseCall = _generateParseCall(
        jsonKey: jsonKey,
        paramType: paramType,
        isNullable: isNullable,
        nullSafety: nullSafety,
        fieldAnnotation: fieldAnnotation,
      );

      if (param.isNamed) {
        buffer.writeln('      $paramName: $parseCall,');
      } else {
        buffer.writeln('      $parseCall,');
      }
    }
    buffer.writeln('    );');
  }

  String _generateParseCall({
    required String jsonKey,
    required DartType paramType,
    required bool isNullable,
    required bool nullSafety,
    SafeJsonFieldAnnotation? fieldAnnotation,
  }) {
    final typeName = paramType.getDisplayString();

    // Handle custom parser if specified
    if (fieldAnnotation?.customParser != null) {
      return isNullable && nullSafety
          ? "json.getNullableSafe('$jsonKey', ${fieldAnnotation!.customParser})"
          : "json.getSafe('$jsonKey', ${fieldAnnotation!.customParser})";
    }

    // Handle enhanced context if specified
    if (fieldAnnotation != null &&
        (fieldAnnotation.description != null ||
            fieldAnnotation.expectedFormat != null ||
            fieldAnnotation.commonValues != null)) {
      final contextParams = <String>[];
      if (fieldAnnotation.description != null) {
        contextParams.add("fieldDescription: '${fieldAnnotation.description}'");
      }
      if (fieldAnnotation.expectedFormat != null) {
        contextParams.add(
          "expectedFormat: '${fieldAnnotation.expectedFormat}'",
        );
      }
      if (fieldAnnotation.commonValues != null) {
        final values = fieldAnnotation.commonValues!
            .map((v) => "'$v'")
            .join(', ');
        contextParams.add("commonValues: [$values]");
      }

      final contextCall =
          contextParams.isNotEmpty ? ', ${contextParams.join(', ')}' : '';

      return isNullable && nullSafety
          ? "json.getNullableSafeWithContext('$jsonKey', ${_getTypeParser(typeName)}$contextCall)"
          : "json.getSafeWithContext('$jsonKey', ${_getTypeParser(typeName)}$contextCall)";
    }

    // Handle common types with convenience methods
    final convenienceMethod = _getConvenienceMethod(
      typeName,
      isNullable && nullSafety,
    );
    if (convenienceMethod != null) {
      return "$convenienceMethod('$jsonKey')";
    }

    // Handle lists
    if (paramType.isDartCoreList) {
      final typeArgs = (paramType as InterfaceType).typeArguments;
      if (typeArgs.isNotEmpty) {
        final elementType = typeArgs.first;
        final elementTypeName = elementType.getDisplayString();
        final elementBaseName = elementTypeName.replaceAll('?', '');

        if (_isCustomClass(elementType)) {
          final parser = '${elementBaseName}SafeJsonParsing.fromJsonSafe';
          return isNullable && nullSafety
              ? "json.getNullableSafeObjectList('$jsonKey', $parser)"
              : "json.getSafeObjectList('$jsonKey', $parser)";
        }

        if (_isEnumType(elementType)) {
          final enumMap = '_\$${elementBaseName}EnumMap';
          final decoder =
              elementType.nullabilitySuffix == NullabilitySuffix.question
                  ? "(v) => \$enumDecodeNullable($enumMap, v)"
                  : "(v) => \$enumDecode($enumMap, v)";
          return isNullable && nullSafety
              ? "json.getNullableSafeList('$jsonKey', $decoder)"
              : "json.getSafeList('$jsonKey', $decoder)";
        }

        final elementParser = _getTypeParser(elementTypeName);
        return isNullable && nullSafety
            ? "json.getNullableSafeList('$jsonKey', $elementParser)"
            : "json.getSafeList('$jsonKey', $elementParser)";
      }
    }

    // Handle nested objects
    if (_isCustomClass(paramType)) {
      final baseTypeName = typeName.replaceAll('?', '');
      final factoryMethod = '${baseTypeName}SafeJsonParsing.fromJsonSafe';
      return isNullable && nullSafety
          ? "json.getNullableSafeObject('$jsonKey', $factoryMethod)"
          : "json.getSafeObject('$jsonKey', $factoryMethod)";
    }

    if (_isEnumType(paramType)) {
      final baseTypeName = typeName.replaceAll('?', '');
      final enumMap = '_\$${baseTypeName}EnumMap';
      final decoder =
          paramType.nullabilitySuffix == NullabilitySuffix.question
              ? "(v) => \$enumDecodeNullable($enumMap, v)!"
              : "(v) => \$enumDecode($enumMap, v)";
      return isNullable && nullSafety
          ? "json.getNullableSafe('$jsonKey', $decoder)"
          : "json.getSafe('$jsonKey', $decoder)";
    }

    // Default generic parser
    final parser = _getTypeParser(typeName);
    return isNullable && nullSafety
        ? "json.getNullableSafe('$jsonKey', $parser)"
        : "json.getSafe('$jsonKey', $parser)";
  }

  String? _getConvenienceMethod(String typeName, bool isNullable) {
    final prefix = isNullable ? 'json.getNullableSafe' : 'json.getSafe';

    // Strip nullable suffix to get base type
    final baseType = typeName.replaceAll('?', '');

    switch (baseType) {
      case 'String':
        return '${prefix}String';
      case 'int':
        return '${prefix}Int';
      case 'double':
        return '${prefix}Double';
      case 'bool':
        return '${prefix}Bool';
      case 'DateTime':
        return '${prefix}DateTime';
      default:
        return null;
    }
  }

  String _getTypeParser(String typeName) {
    final normalizedType = typeName.replaceAll('?', '');
    switch (normalizedType) {
      case 'String':
        return '(v) => v as String';
      case 'int':
        return '(v) => (v as num).toInt()';
      case 'double':
        return '(v) => (v as num).toDouble()';
      case 'bool':
        return '(v) => v as bool';
      case 'DateTime':
        return '(v) => DateTime.parse(v as String)';
      case 'num':
        return '(v) => v as num';
      default:
        return '(v) => v as $normalizedType';
    }
  }

  bool _isNullable(DartType type) {
    return type.nullabilitySuffix == NullabilitySuffix.question;
  }

  bool _isCustomClass(DartType type) {
    final element = type.element;
    return element is ClassElement &&
        !type.isDartCoreList &&
        !type.isDartCoreMap &&
        !type.isDartCoreSet &&
        element.library.isDartCore != true;
  }

  bool _isEnumType(DartType type) {
    final element = type.element;
    return element is EnumElement;
  }

  String _getJsonKeyFromField(FieldElement field) {
    // TODO: Re-implement @JsonKey support with correct analyzer API
    // For now, return the field name directly
    return field.name ?? 'field';
  }

  SafeJsonFieldAnnotation? _getSafeJsonFieldAnnotationFromField(
    FieldElement field,
  ) {
    // TODO: Re-implement @SafeJsonField support with correct analyzer API
    // For now, return a default configuration
    return SafeJsonFieldAnnotation(
      description: null,
      expectedFormat: null,
      commonValues: null,
      customParser: null,
      enhancedErrors: true,
    );
  }
}

/// Internal representation of SafeJsonField annotation data
///
/// This class holds the parsed configuration from @SafeJsonField annotations
/// and is used internally by the code generator to create enhanced error messages.
class SafeJsonFieldAnnotation {
  /// Human-readable description of what this field represents
  ///
  /// Used in error messages to provide context about the field's purpose.
  /// Example: "User email address" or "Product price in USD"
  final String? description;

  /// Expected format or example value for this field
  ///
  /// Shown in error messages to help developers understand the expected format.
  /// Example: "user@example.com" or "Positive number (e.g., 19.99)"
  final String? expectedFormat;

  /// List of common/valid values for this field
  ///
  /// Displayed in error messages as examples of acceptable values.
  /// Example: ['9.99', '19.99', '29.99'] for a price field
  final List<String>? commonValues;

  /// Name of a custom static parser method to use for this field
  ///
  /// References a static method that should handle parsing this specific field.
  /// The method should have signature: `static T methodName(dynamic value)`
  final String? customParser;

  /// Whether this field should use enhanced error reporting
  ///
  /// When true, generates detailed error messages with context and suggestions.
  /// When false, uses standard error reporting. Defaults to true.
  final bool enhancedErrors;

  /// Creates a new SafeJsonFieldAnnotation with the specified configuration
  ///
  /// This constructor is used internally by the code generator to create
  /// annotation instances from @SafeJsonField metadata.
  SafeJsonFieldAnnotation({
    this.description,
    this.expectedFormat,
    this.commonValues,
    this.customParser,
    required this.enhancedErrors,
  });
}

/// Builder for the safe JSON parsing generator
Builder safeJsonParsingBuilder(BuilderOptions options) {
  return PartBuilder([SafeJsonParsingGenerator()], '.safe_json_parsing.g.dart');
}
