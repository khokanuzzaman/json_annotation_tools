import 'dart:async';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';
import 'annotations.dart';

/// Code generator for @SafeJsonParsing annotation
/// 
/// This generator creates enhanced fromJsonSafe() methods that provide
/// crystal-clear error messages and automatic safe parsing.
class SafeJsonParsingGenerator extends GeneratorForAnnotation<SafeJsonParsing> {
  @override
  FutureOr<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) {
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
        '@SafeJsonParsing can only be applied to classes',
        element: element,
      );
    }

    return _generateSafeJsonMethod(element, annotation);
  }

  String _generateSafeJsonMethod(ClassElement classElement, ConstantReader annotation) {
    final className = classElement.name;
    final nullSafety = annotation.read('nullSafety').boolValue;
    final validateRequiredKeys = annotation.read('validateRequiredKeys').boolValue;
    final methodName = annotation.read('methodName').stringValue;

    // Note: We use field-based generation, so no constructor validation needed

    final buffer = StringBuffer();
    
    // Generate the safe parsing method
    buffer.writeln('// Enhanced JSON parsing extension for $className');
    buffer.writeln('extension ${className}SafeJsonParsing on $className {');
    buffer.writeln('  /// Enhanced JSON parsing with detailed error messages');
    buffer.writeln('  /// ');
    buffer.writeln('  /// This method provides crystal-clear error messages when JSON parsing fails,');
    buffer.writeln('  /// including the exact field that caused the error, expected vs actual types,');
    buffer.writeln('  /// and copy-paste ready solutions to fix the issue.');
    buffer.writeln('  /// ');
    buffer.writeln('  /// Generated by @SafeJsonParsing annotation');
    buffer.writeln('  static $className $methodName(Map<String, dynamic> json) {');

    // Add required keys validation if requested
    if (validateRequiredKeys) {
      final requiredKeys = classElement.fields
          .where((f) => !f.type.isDartCoreNull && !_isNullable(f.type))
          .map((f) => "'${_getJsonKeyFromField(f)}'")
          .toList();
      
      if (requiredKeys.isNotEmpty) {
        buffer.writeln('    json.requireKeys([${requiredKeys.join(', ')}]);');
        buffer.writeln('');
      }
    }

    // Generate the constructor call with safe parsing
    buffer.writeln('    return $className(');
    
    for (final field in classElement.fields) {
      if (field.isStatic) continue;
      final fieldName = field.name;
      final jsonKey = _getJsonKeyFromField(field);
      final isNullable = _isNullable(field.type);
      final fieldAnnotation = _getSafeJsonFieldAnnotationFromField(field);
      
      // Generate safe parsing call based on type and nullability
      final parseCall = _generateParseCall(
        jsonKey: jsonKey, 
        paramType: field.type, 
        isNullable: isNullable,
        nullSafety: nullSafety,
        fieldAnnotation: fieldAnnotation,
      );
      
      buffer.writeln('      $fieldName: $parseCall,');
    }
    
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');

    return buffer.toString();
  }

  String _generateParseCall({
    required String jsonKey,
    required DartType paramType,
    required bool isNullable,
    required bool nullSafety,
    SafeJsonFieldAnnotation? fieldAnnotation,
  }) {
    final typeName = paramType.getDisplayString();
    
    // Handle custom parser if specified
    if (fieldAnnotation?.customParser != null) {
      return isNullable && nullSafety
          ? "json.getNullableSafe('$jsonKey', ${fieldAnnotation!.customParser})"
          : "json.getSafe('$jsonKey', ${fieldAnnotation!.customParser})";
    }

    // Handle enhanced context if specified
    if (fieldAnnotation != null && (
        fieldAnnotation.description != null ||
        fieldAnnotation.expectedFormat != null ||
        fieldAnnotation.commonValues != null)) {
      
      final contextParams = <String>[];
      if (fieldAnnotation.description != null) {
        contextParams.add("fieldDescription: '${fieldAnnotation.description}'");
      }
      if (fieldAnnotation.expectedFormat != null) {
        contextParams.add("expectedFormat: '${fieldAnnotation.expectedFormat}'");
      }
      if (fieldAnnotation.commonValues != null) {
        final values = fieldAnnotation.commonValues!.map((v) => "'$v'").join(', ');
        contextParams.add("commonValues: [$values]");
      }
      
      final contextCall = contextParams.isNotEmpty ? ', ${contextParams.join(', ')}' : '';
      
      return isNullable && nullSafety
          ? "json.getNullableSafeWithContext('$jsonKey', ${_getTypeParser(typeName)}$contextCall)"
          : "json.getSafeWithContext('$jsonKey', ${_getTypeParser(typeName)}$contextCall)";
    }

    // Handle common types with convenience methods
    final convenienceMethod = _getConvenienceMethod(typeName, isNullable && nullSafety);
    if (convenienceMethod != null) {
      return "$convenienceMethod('$jsonKey')";
    }

    // Handle lists
    if (paramType.isDartCoreList) {
      final typeArgs = (paramType as InterfaceType).typeArguments;
      if (typeArgs.isNotEmpty) {
        final elementType = typeArgs.first;
        final elementTypeName = elementType.getDisplayString();
        final elementParser = _getTypeParser(elementTypeName);
        
        return isNullable && nullSafety
            ? "json.getNullableSafeList('$jsonKey', $elementParser)"
            : "json.getSafeList('$jsonKey', $elementParser)";
      }
    }

    // Handle nested objects
    if (_isCustomClass(paramType)) {
      final factoryMethod = '$typeName.fromJsonSafe';
      return isNullable && nullSafety
          ? "json.getNullableSafeObject('$jsonKey', $factoryMethod)"
          : "json.getSafeObject('$jsonKey', $factoryMethod)";
    }

    // Default generic parser
    final parser = _getTypeParser(typeName);
    return isNullable && nullSafety
        ? "json.getNullableSafe('$jsonKey', $parser)"
        : "json.getSafe('$jsonKey', $parser)";
  }

  String? _getConvenienceMethod(String typeName, bool isNullable) {
    final prefix = isNullable ? 'json.getNullableSafe' : 'json.getSafe';
    
    // Strip nullable suffix to get base type
    final baseType = typeName.replaceAll('?', '');
    
    switch (baseType) {
      case 'String': return '${prefix}String';
      case 'int': return '${prefix}Int';
      case 'double': return '${prefix}Double';
      case 'bool': return '${prefix}Bool';
      case 'DateTime': return '${prefix}DateTime';
      default: return null;
    }
  }

  String _getTypeParser(String typeName) {
    switch (typeName) {
      case 'String': return '(v) => v as String';
      case 'int': return '(v) => (v as num).toInt()';
      case 'double': return '(v) => (v as num).toDouble()';
      case 'bool': return '(v) => v as bool';
      case 'DateTime': return '(v) => DateTime.parse(v as String)';
      default: return '(v) => v as $typeName';
    }
  }

  bool _isNullable(DartType type) {
    return type.nullabilitySuffix == NullabilitySuffix.question;
  }

  bool _isCustomClass(DartType type) {
    return !type.isDartCoreType && 
           !type.isDartCoreList && 
           !type.isDartCoreMap &&
           !type.isDartCoreSet;
  }


  String _getJsonKeyFromField(FieldElement field) {
    // TODO: Re-implement @JsonKey support with correct analyzer API
    // For now, return the field name directly
    return field.name ?? 'field';
  }


  SafeJsonFieldAnnotation? _getSafeJsonFieldAnnotationFromField(FieldElement field) {
    // TODO: Re-implement @SafeJsonField support with correct analyzer API
    // For now, return a default configuration
    return SafeJsonFieldAnnotation(
      description: null,
      expectedFormat: null,
      commonValues: null,
      customParser: null,
      enhancedErrors: true,
    );
  }
}

/// Internal representation of SafeJsonField annotation data
/// 
/// This class holds the parsed configuration from @SafeJsonField annotations
/// and is used internally by the code generator to create enhanced error messages.
class SafeJsonFieldAnnotation {
  /// Human-readable description of what this field represents
  /// 
  /// Used in error messages to provide context about the field's purpose.
  /// Example: "User email address" or "Product price in USD"
  final String? description;
  
  /// Expected format or example value for this field
  /// 
  /// Shown in error messages to help developers understand the expected format.
  /// Example: "user@example.com" or "Positive number (e.g., 19.99)"
  final String? expectedFormat;
  
  /// List of common/valid values for this field
  /// 
  /// Displayed in error messages as examples of acceptable values.
  /// Example: ['9.99', '19.99', '29.99'] for a price field
  final List<String>? commonValues;
  
  /// Name of a custom static parser method to use for this field
  /// 
  /// References a static method that should handle parsing this specific field.
  /// The method should have signature: `static T methodName(dynamic value)`
  final String? customParser;
  
  /// Whether this field should use enhanced error reporting
  /// 
  /// When true, generates detailed error messages with context and suggestions.
  /// When false, uses standard error reporting. Defaults to true.
  final bool enhancedErrors;

  /// Creates a new SafeJsonFieldAnnotation with the specified configuration
  /// 
  /// This constructor is used internally by the code generator to create
  /// annotation instances from @SafeJsonField metadata.
  SafeJsonFieldAnnotation({
    this.description,
    this.expectedFormat,
    this.commonValues,
    this.customParser,
    required this.enhancedErrors,
  });
}

/// Builder for the safe JSON parsing generator
Builder safeJsonParsingBuilder(BuilderOptions options) {
  return PartBuilder([SafeJsonParsingGenerator()], '.safe_json_parsing.g.dart');
}
